{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React from 'react';\nvar SUPPORTED_ANIMATIONS = ['cross-dissolve', 'flip-from-left', 'flip-from-right', 'flip-from-top', 'flip-from-bottom'];\nfunction useAnimationManagerNode(node, initialStatus) {\n  var newNode = React.useMemo(function () {\n    if (!node) {\n      return null;\n    }\n    var _node = _slicedToArray(node, 2),\n      animationKey = _node[0],\n      renderFunction = _node[1];\n    return {\n      animationKey: animationKey,\n      persistedElement: renderFunction,\n      status: initialStatus || 'mounted'\n    };\n  }, [node == null ? void 0 : node[0]]);\n  return newNode;\n}\nfunction validateTimingFunctionForAnimation(animationClass, timingFunction) {\n  if (animationClass != null && animationClass.includes('flip')) {\n    if (timingFunction != null && timingFunction.includes('ease')) {\n      return 'ease-in-out';\n    }\n    return 'linear';\n  }\n  return timingFunction || null;\n}\nfunction validateAnimationClass(effect) {\n  if (SUPPORTED_ANIMATIONS.includes(effect)) {\n    return effect;\n  }\n  return 'cross-dissolve';\n}\nexport function getAnimatorFromTransition(transition) {\n  if (!(transition != null && transition.duration)) {\n    return null;\n  }\n  var animationClass = validateAnimationClass(transition.effect);\n  if (!animationClass) {\n    return {\n      startingClass: '',\n      animateInClass: '',\n      animateOutClass: '',\n      containerClass: '',\n      timingFunction: 'linear',\n      animationClass: '',\n      duration: 0\n    };\n  }\n  var timingFunction = validateTimingFunctionForAnimation(animationClass, transition.timing);\n  var timingClass = \"image-timing-\" + timingFunction;\n  return {\n    startingClass: animationClass + \"-start\",\n    animateInClass: [animationClass, 'transitioning', animationClass + \"-active\", timingClass].join(' '),\n    animateOutClass: [animationClass, animationClass + \"-end\", timingClass].join(' '),\n    containerClass: animationClass + \"-container\",\n    timingFunction: timingFunction,\n    animationClass: animationClass,\n    duration: (transition == null ? void 0 : transition.duration) || 0\n  };\n}\nexport default function AnimationManager(_ref) {\n  var renderFunction = _ref.children,\n    initial = _ref.initial,\n    transition = _ref.transition;\n  var animation = getAnimatorFromTransition(transition);\n  var initialNode = useAnimationManagerNode(initial, 'active');\n  var _React$useState = React.useState(initialNode ? [initialNode] : []),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    nodes = _React$useState2[0],\n    setNodes = _React$useState2[1];\n  var removeAllNodesOfKeyExceptShowing = function removeAllNodesOfKeyExceptShowing(key) {\n    setNodes(function (n) {\n      return n.filter(function (node) {\n        return (key ? node.animationKey !== key : false) || node.status === 'in' || node.status === 'active';\n      });\n    });\n  };\n  var newNode = useAnimationManagerNode(renderFunction);\n  React.useEffect(function () {\n    setNodes(function (n) {\n      if (!newNode) {\n        return n;\n      }\n      var existingNodeIndex = n.findIndex(function (node) {\n        return node.animationKey === newNode.animationKey;\n      });\n      if (existingNodeIndex >= 0) {\n        var copy = _toConsumableArray(n);\n        copy.splice(existingNodeIndex, 1, newNode);\n        return copy;\n      }\n      return [].concat(_toConsumableArray(n), [newNode]);\n    });\n  }, [newNode]);\n  function wrapNodeWithCallbacks(node) {\n    if (renderFunction[0] === node.animationKey) {\n      return renderFunction[1]({\n        onReady: function onReady() {\n          if (animation) {\n            setNodes(function (nodes) {\n              return nodes.map(function (n) {\n                return n === newNode ? _objectSpread(_objectSpread({}, n), {}, {\n                  status: 'in'\n                }) : _objectSpread(_objectSpread({}, n), {}, {\n                  status: 'out'\n                });\n              });\n            });\n          } else {\n            setNodes([_objectSpread(_objectSpread({}, node), {}, {\n              status: 'in'\n            })]);\n          }\n        },\n        onAnimationFinished: function onAnimationFinished() {\n          setNodes([_objectSpread(_objectSpread({}, node), {}, {\n            status: 'in'\n          })]);\n        },\n        onError: function onError() {\n          setNodes(function (nodes) {\n            return nodes.map(function (n) {\n              return n === node ? _objectSpread(_objectSpread({}, n), {}, {\n                status: 'errored'\n              }) : n;\n            });\n          });\n        }\n      });\n    }\n    if ((initial == null ? void 0 : initial[0]) === node.animationKey) {\n      return initial[1]({\n        onAnimationFinished: function onAnimationFinished() {\n          if (node.status === 'out') {\n            removeAllNodesOfKeyExceptShowing(node.animationKey);\n          }\n        },\n        onError: function onError() {\n          setNodes(function (nodes) {\n            return nodes.map(function (n) {\n              return n === node ? _objectSpread(_objectSpread({}, n), {}, {\n                status: 'errored'\n              }) : n;\n            });\n          });\n        }\n      });\n    }\n    return node.persistedElement({\n      onAnimationFinished: function onAnimationFinished() {\n        removeAllNodesOfKeyExceptShowing(node.animationKey);\n      }\n    });\n  }\n  var styles = {\n    transitionDuration: ((animation == null ? void 0 : animation.duration) || 0) + \"ms\",\n    transitionTimingFunction: (animation == null ? void 0 : animation.timingFunction) || 'linear'\n  };\n  var classes = {\n    in: animation == null ? void 0 : animation.animateInClass,\n    out: animation == null ? void 0 : animation.animateOutClass,\n    mounted: animation == null ? void 0 : animation.startingClass\n  };\n  return React.createElement(React.Fragment, null, _toConsumableArray(nodes).filter(function (n) {\n    return n.status !== 'errored';\n  }).map(function (n) {\n    return React.createElement(\"div\", {\n      className: animation == null ? void 0 : animation.containerClass,\n      key: n.animationKey\n    }, wrapNodeWithCallbacks(n)(classes[n.status], styles));\n  }));\n}","map":{"version":3,"names":["React","SUPPORTED_ANIMATIONS","useAnimationManagerNode","node","initialStatus","newNode","useMemo","_node","_slicedToArray","animationKey","renderFunction","persistedElement","status","validateTimingFunctionForAnimation","animationClass","timingFunction","includes","validateAnimationClass","effect","getAnimatorFromTransition","transition","duration","startingClass","animateInClass","animateOutClass","containerClass","timing","timingClass","join","AnimationManager","_ref","children","initial","animation","initialNode","_React$useState","useState","_React$useState2","nodes","setNodes","removeAllNodesOfKeyExceptShowing","key","n","filter","useEffect","existingNodeIndex","findIndex","copy","_toConsumableArray","splice","concat","wrapNodeWithCallbacks","onReady","map","_objectSpread","onAnimationFinished","onError","styles","transitionDuration","transitionTimingFunction","classes","in","out","mounted","createElement","Fragment","className"],"sources":["G:\\Pro\\locofy-react-native-project (3)\\node_modules\\expo-image\\src\\web\\AnimationManager.tsx"],"sourcesContent":["import React from 'react';\n\nimport { ImageTransition } from '../Image.types';\n\ntype Callbacks = {\n  onReady?: (() => void) | null;\n  onAnimationFinished?: (() => void) | null;\n  onMount?: (() => void) | null;\n  onError?: (() => void) | null;\n};\n\ntype AnimationManagerNode = [\n  key: string,\n  renderFunction: (\n    renderProps: NonNullable<Callbacks>\n  ) => (className: string, style: React.CSSProperties) => React.ReactElement\n];\n\nconst SUPPORTED_ANIMATIONS: ImageTransition['effect'][] = [\n  'cross-dissolve',\n  'flip-from-left',\n  'flip-from-right',\n  'flip-from-top',\n  'flip-from-bottom',\n];\n\ntype NodeStatus = 'mounted' | 'in' | 'active' | 'out' | 'errored';\n\nfunction useAnimationManagerNode(node: AnimationManagerNode | null, initialStatus?: NodeStatus) {\n  const newNode = React.useMemo(() => {\n    if (!node) {\n      return null;\n    }\n    const [animationKey, renderFunction] = node;\n    // key, ReactElement, ref, callbacks\n    return {\n      animationKey,\n      persistedElement: renderFunction,\n      status: (initialStatus || 'mounted') as NodeStatus,\n    };\n  }, [node?.[0]]);\n  return newNode;\n}\n\nfunction validateTimingFunctionForAnimation(\n  animationClass: ImageTransition['effect'],\n  timingFunction: ImageTransition['timing']\n) {\n  if (animationClass?.includes('flip')) {\n    if (timingFunction?.includes('ease')) {\n      return 'ease-in-out';\n    }\n    return 'linear';\n  }\n  return timingFunction || null;\n}\n\nfunction validateAnimationClass(effect: ImageTransition['effect']) {\n  if (SUPPORTED_ANIMATIONS.includes(effect)) {\n    return effect;\n  }\n  return 'cross-dissolve';\n}\n\nexport function getAnimatorFromTransition(transition: ImageTransition | null | undefined) {\n  if (!transition?.duration) {\n    return null;\n  }\n  const animationClass = validateAnimationClass(transition.effect);\n  if (!animationClass) {\n    return {\n      startingClass: '',\n      animateInClass: '',\n      animateOutClass: '',\n      containerClass: '',\n      timingFunction: 'linear',\n      animationClass: '',\n      duration: 0,\n    };\n  }\n\n  const timingFunction = validateTimingFunctionForAnimation(animationClass, transition.timing);\n  const timingClass = `image-timing-${timingFunction}`;\n\n  return {\n    startingClass: `${animationClass}-start`,\n    animateInClass: [animationClass, 'transitioning', `${animationClass}-active`, timingClass].join(\n      ' '\n    ),\n    animateOutClass: [animationClass, `${animationClass}-end`, timingClass].join(' '),\n    containerClass: `${animationClass}-container`,\n    timingFunction,\n    animationClass,\n    duration: transition?.duration || 0,\n  };\n}\n\ntype MountedAnimationNode = {\n  animationKey: string;\n  persistedElement: (\n    renderProps: Callbacks\n  ) => (className: string, style: React.CSSProperties) => React.ReactElement;\n  status: NodeStatus;\n};\n\nexport default function AnimationManager({\n  children: renderFunction,\n  initial,\n  transition,\n}: {\n  children: AnimationManagerNode;\n  initial: AnimationManagerNode | null;\n  transition: ImageTransition | null | undefined;\n}) {\n  const animation = getAnimatorFromTransition(transition);\n\n  const initialNode = useAnimationManagerNode(initial, 'active');\n\n  const [nodes, setNodes] = React.useState<MountedAnimationNode[]>(\n    initialNode ? [initialNode] : []\n  );\n\n  const removeAllNodesOfKeyExceptShowing = (key?: string) => {\n    setNodes((n) =>\n      n.filter(\n        (node) =>\n          (key ? node.animationKey !== key : false) ||\n          node.status === 'in' ||\n          node.status === 'active'\n      )\n    );\n  };\n\n  const newNode = useAnimationManagerNode(renderFunction);\n\n  React.useEffect(() => {\n    setNodes((n) => {\n      if (!newNode) {\n        return n;\n      }\n      const existingNodeIndex = n.findIndex((node) => node.animationKey === newNode.animationKey);\n      if (existingNodeIndex >= 0) {\n        const copy = [...n];\n        copy.splice(existingNodeIndex, 1, newNode);\n        return copy;\n      }\n      return [...n, newNode];\n    });\n  }, [newNode]);\n\n  function wrapNodeWithCallbacks(node: MountedAnimationNode) {\n    if (renderFunction[0] === node.animationKey) {\n      return renderFunction[1]({\n        onReady: () => {\n          if (animation) {\n            setNodes((nodes) =>\n              nodes.map((n) => (n === newNode ? { ...n, status: 'in' } : { ...n, status: 'out' }))\n            );\n          } else {\n            setNodes([{ ...node, status: 'in' }]);\n          }\n        },\n        onAnimationFinished: () => {\n          setNodes([{ ...node, status: 'in' }]);\n        },\n        onError: () => {\n          setNodes((nodes) => nodes.map((n) => (n === node ? { ...n, status: 'errored' } : n)));\n        },\n      });\n    }\n    if (initial?.[0] === node.animationKey) {\n      return initial[1]({\n        onAnimationFinished: () => {\n          if (node.status === 'out') {\n            removeAllNodesOfKeyExceptShowing(node.animationKey);\n          }\n        },\n        onError: () => {\n          setNodes((nodes) => nodes.map((n) => (n === node ? { ...n, status: 'errored' } : n)));\n        },\n      });\n    }\n    return node.persistedElement({\n      onAnimationFinished: () => {\n        removeAllNodesOfKeyExceptShowing(node.animationKey);\n      },\n    });\n  }\n  const styles = {\n    transitionDuration: `${animation?.duration || 0}ms`,\n    transitionTimingFunction: animation?.timingFunction || 'linear',\n  };\n  const classes = {\n    in: animation?.animateInClass,\n    out: animation?.animateOutClass,\n    mounted: animation?.startingClass,\n  };\n\n  return (\n    <>\n      {[...nodes]\n        .filter((n) => n.status !== 'errored')\n        .map((n) => (\n          <div className={animation?.containerClass} key={n.animationKey}>\n            {wrapNodeWithCallbacks(n)(classes[n.status], styles)}\n          </div>\n        ))}\n    </>\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}